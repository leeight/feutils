/***************************************************************************
 * 
 * Copyright (c) 2011 Baidu.com, Inc. All Rights Reserved
 * $Id$ 
 * 
 **************************************************************************/
 
 
 
/**
 * server3.js ~ 2011/10/19 17:32:10
 * @author leeight(liyubei@baidu.com)
 * @version $Revision$ 
 * @description 
 *  
 **/

var static = require('node-static'),
    fs = require('fs'),
    url = require('url'),
    util = require('util'),
    colors = require('colors'),
    http = require('http'),
    path = require('path'),
    events = require('events'),
    Mu = require('./lib/mu');

Mu.templateRoot = __dirname;

var argv = require('optimist')
           .demand(['root', 'port'])
           .describe('root', _('server webroot directory'))
           .describe('port', _('server port'))
           .describe('config', _('configuration in json format'))
           .default('root', '.')
           .default('port', '8080')
           .argv;

function _(message) {
  return message;
}

var proxyMap = null;
if (argv.config) {
  proxyMap = JSON.parse(fs.readFileSync(argv.config));
  log('proxyMap = ' + JSON.stringify(proxyMap));
}

function getMatchedHost(host) {
  if (proxyMap && proxyMap[host]) {
    var matched = proxyMap[host].split(':');
    if (matched.length == 1) {
      matched.push(80);
    }
    return matched;
  }
}

function log(message) {
  var now = new Date();
  util.puts('[' + now.getFullYear() + '/' + (now.getMonth() + 1) + '/' + now.getDay() + ' ' + now.getHours() + ':' + now.getMinutes() + ':' + now.getSeconds() + '] ' + message);
}

function proxyRequest(request, response, chunks) {
  var host = getMatchedHost(request.headers['host']);
  if (!host) {
    log('can not find matched host for ' + request.headers['host'].red);
    // TODO 404 error.
    response.writeHead(404, {});
    response.end();
  } else {
    log('forward request ' + (request.headers['host'] + request.url).blue + 
        ' to ' + (host[0] + ':' + host[1] + request.url).blue);
    var proxy = http.createClient(parseInt(host[1], 10), host[0]);
    var proxy_request = proxy.request(request.method, request.url, request.headers);
    var response_chunks = [];
    proxy_request.addListener('response', function (proxy_response) {
      proxy_response.addListener('data', function(chunk) {
        response_chunks.push(chunk);
      });
      proxy_response.addListener('end', function() {
        var response_body = response_chunks.join('');
        var response_headers = proxy_response.headers;
        if (response_headers["transfer-encoding"] == "chunked") {
          delete response_headers["transfer-encoding"];
        }
        response_headers["content-length"] = Buffer.byteLength(response_body, "utf8");
        // log(JSON.stringify(response_headers).yellow);
        response.writeHead(proxy_response.statusCode, response_headers);
        response.write(response_body);
        response.end();
      });
      // log(JSON.stringify(proxy_response.headers).yellow);
    });
    proxy_request.write(chunks.join(''), 'binary');
    proxy_request.end();
  }
}

/**
 * @constructor
 */
function ErServer() {
  this._handlers = {};
  this.file = new(static.Server)(argv.root);
}

/**
 * @param {string} url 需要处理的url，也就是url中的pathname部分.
 * @param {Function} handler 自定义的处理函数.
 */
ErServer.prototype.addHandler = function(url, handler) {
  this._handlers[url] = handler;
}

/**
 * 根据url获取服务器上面的绝对路径.
 * @return {string}
 */
ErServer.prototype.getAbsPath = function(pathname) {
  return this.file.resolve(decodeURI(pathname));
}

/**
 * 当访问的是一个目录的时候，列出目录列表.
 * @param {string} dir 目录的绝对路径.
 * @param {*} request http request.
 * @param {*} response http response.
 */
ErServer.prototype.listDirectory = function(dir, request, response) {
  var me = this;
  fs.readdir(dir, function(err, files){
    var list = [];
    files.forEach(function(file){
      var stat = fs.statSync(path.join(dir, file));
      list.push({
        'name' : stat.isDirectory() ? file + '/' :  file,
        'url' : encodeURIComponent(file) + (stat.isDirectory() ? '/' : ''),
        'size' : stat.size,
        'mtime' : stat.mtime,
      });
    });

    var html = Mu.render('dirlist', {
      'files' : list
    }, {}, function(err, output){
      var chunks = [];
      output.addListener('data', function(c){ chunks.push(c); })
            .addListener('end', function(){
        response.writeHead(200, {
          'Content-Type' : 'text/html; charset=UTF-8'
        });
        response.write(chunks.join(''));
        response.end();
      });
    });
  });
}

/**
 * 启动ErServer
 */
ErServer.prototype.start = function() {
  var me = this;
  var file = me.file;
  log("Server started. port = [" + argv.port + "], root = [" + argv.root + "]");
  http.createServer(function(request, response){
    var chunks = [];
    request.addListener('data', function(chunk){
      chunks.push(chunk);
    });

    request.addListener('end', function (){
      var parsed_url = url.parse(request.url);
      var handler = null;
      var sendResponse = function(response, pathname, body) {
        response.writeHead(200, {
          'Content-Length' : Buffer.byteLength(body, 'utf8'),
          'Content-Type' : file.mimeType(pathname)
        });
        response.write(body.toString());
        response.end();
      }

      if (handler = me._handlers[decodeURI(parsed_url.pathname)]) {
        // 存在自定义的处理函数.
        try {
          var rv = handler(request, response, chunks.join(''));
          if (typeof rv === 'string') {
            sendResponse(response, parsed_url.pathname, rv);
          } else if (typeof rv === 'object' &&
                     rv.constructor === events.EventEmitter){
            rv.on('success', function(css) {
              sendResponse(response, parsed_url.pathname, css);
            });
            rv.on('error', function(error) {
              sendResponse(response, parsed_url.pathname, error.message);
            })
          }
        } catch(e) {
          response.writeHead(500, {});
          response.write(e.message);
        } finally {
          // response.end();
        }
      } else {
        var pathname = me.getAbsPath(parsed_url.pathname);
        fs.stat(pathname, function(error, stats){
          if (!error) {
            if (stats.isDirectory()) {
              if (!parsed_url.pathname.match(/\/$/)) {
                response.writeHead(302, {
                  "Location" : parsed_url.pathname + '/'
                });
                response.end();
              } else {
                me.listDirectory(pathname, request, response);
              }
            } else {
              file.serve(request, response);
            }
          } else {
            // 静态文件不存在，去请求proxyMap里面的数据.
            proxyRequest(request, response, chunks);
          }
        });
      }
    });
  }).listen(parseInt(argv.port, 10));
}

exports.ErServer = ErServer;
exports.log = log;














/* vim: set ts=4 sw=4 sts=4 tw=100 noet: */
