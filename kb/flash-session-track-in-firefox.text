% Firefox 下用 Flash 上传文件的会话保持问题
% guyiling
% 2011-11-15
% firefox,flash,cookie,session

## 问题简述

在 Firefox 下利用 Flash 控件上传文件(例如 SWFUpload)时，Flash 发起的请求不使用与 Firefox 中相同的 cookie，导致服务器端 session 信息丢失及后续可能的一系列问题。

## 问题详解
[Adobe 官方文档](http://cookbooks.adobe.com/post_Why_is_session_info__cookies__not_sent_when_upload-12029.html "Why is session info &#40;cookies&#41; not sent when uploading files in Firefox?")称，Flash 在上传文件时不使用 Firefox 的 cookie：

     “A FileReference.upload() currently does not use the same cookies as your browser
     session if you are using Firefox (on Windows). In such cases, cookie information
     has to be inserted manually.”

对于这种无法直接依赖浏览器中 cookie 进行会话保持的情况，首先需要将 session ID 通过其他方式传递给服务器。

可选的方案有：

1. 将 session ID 作为请求参数传递给服务器。这时服务器端可能需要对 session ID 进行额外处理(PHP会自动解析名为PHPSESSID的参数作为 session ID)。
2. 使用带 session ID 的 URL 重写：以 J2EE 为例，可在请求 URL 中拼接 ;jsessionid=xxx 字符串来进行显式 session ID 的传递。注意对于 ;jsessionid=xxx 这种形式必须写在路径与参数之间，比如

        http://example.com/upload;jsessionid=xxx?x=0

注意上面说的是使用的非相同的 cookie，并非 Flash 在上传时不带 cookie。当 session 超时后，以 Tomcat 为例，会为带超时 session ID 的请求分配新的 session ID 并返回 Set-Cookie:JSESSIONID=xxx 这样的 HTTP 头。用户重新登陆后虽然 Flash 发起上传请求时已经显式传递了新 session ID，但一般服务器端默认处理均为优先取 cookie 中的值，导致新的已登录的 session ID 在 Flash 上传时无法生效。在客户端无法利用 JavaScript 清除 Flash cookie，导致必须重启浏览器才能结束无效 session ID 的影响。对这种情况可以在处理 Flash 上传请求的页面响应中追加一个响应头：

    Set-Cookie:JSESSIONID="";Max-Age=0

这可以用来删除这个不需要的 session ID，这样重新登录后 Flash 能够一直保持使用显式传递的 session ID 来进行上传。

下面是整个问题产生过程的示意图(以 J2EE 为例)：

![1st Flash Request](demo/ff-flash-session-track-1.png "1st Flash Request")

登陆后 Flash 第一次进行上传时，自身没有 JSESSIONID 这个 Cookie，所以使用手工拼接到请求 URL 中的浏览器 JSESSIONID 即 XXX 进行提交，服务器解析出了 JSESSIONID 并且在内存中找到了其对应的 session 信息，成功进行了身份验证，最后返回上传成功的信息。

![2nd Flash Request](demo/ff-flash-session-track-2.png "2nd Flash Request")

然而当 XXX 这个 session ID 超时以后，Flash 仍然以刚才重写过的 URL 发送请求(图中[1])，服务器解析出 JSESSIONID 后发现已经没有 XXX 这个 session 了，于是重新创建了一个 ID 为 YYY 的 session(图中[2])，并且在返回的响应中除了登陆失败的信息外还加入了 SET-COOKIE:JSESSIONID=YYY 的请求头(图中[3])。于是这时在 Flash 的 LSO (“Flash cookies”) 中却把这个不带用户登录信息的 session ID 保存了下来。

![3rd Flash Request](demo/ff-flash-session-track-3.png "3rd Flash Request")

发现登陆超时后，用户重新登陆，在新的 ID 为 ZZZ 的 session 中留下了有效的登录信息，进入上传页面后，生成了新的拼接 JSESSIONID 的 URL 传递给 Flash 控件，此时进行上传时， Flash 发送的请求既包含了 URL 中的 JSESSIONID，也带了 Cookie 请求头中的 JSESSIONID(图中[1])。按 Servlet 规范，当请求有 Cookie 头中的 JSESSIONID 时，URL 中的就被忽略了，于是服务端判断此请求应该在 YYY 这个 session 中进行处理(图中[2])，于是导致了用户看似已登录，Flash 请求却使用了另一未登录的 session 导致上传失败。

## 解决方法总结

1. 首先要对 Flash 上传的请求地址利用参数传递或 URL 重写显式传递 session ID。
2. 对处理 Flash 文件上传请求的页面在验证失败时不分配新 session ID 或利用 Max-Age=0 来立即删除无用的 cookie。

##影响范围
Firefox